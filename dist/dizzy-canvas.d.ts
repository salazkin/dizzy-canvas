// Generated by dts-bundle-generator v4.2.0

export declare type Matrix = {
	a: number;
	b: number;
	c: number;
	d: number;
	tx: number;
	ty: number;
};
export declare class Transform {
	x: number;
	y: number;
	scaleX: number;
	scaleY: number;
	skewX: number;
	skewY: number;
	rotation: number;
	matrix: Matrix;
	matrixUpdated: boolean;
	equalScale: boolean;
	noScale: boolean;
	equalSkew: boolean;
	noSkew: boolean;
	updateInfo(): void;
	updateMatrix(): void;
	concat(local: Transform, global: Transform): void;
	copy(target: Transform): void;
}
export declare class Node {
	transform: {
		local: Transform;
		global: Transform;
		globalTransformUpdated: boolean;
	};
	readonly children: Node[];
	protected readonly hierarchy: Node[];
	parent: Node | null;
	name: string;
	constructor(id?: string);
	set x(value: number);
	get x(): number;
	set y(value: number);
	get y(): number;
	set scaleX(value: number);
	get scaleX(): number;
	set scaleY(value: number);
	get scaleY(): number;
	set skewX(value: number);
	get skewX(): number;
	set skewY(value: number);
	get skewY(): number;
	set rotation(value: number);
	get rotation(): number;
	setPosition(x: number, y: number): void;
	setScale(x?: number, y?: number): void;
	setSkew(x: number, y: number): void;
	addChild(node: Node): Node;
	removeChild(node: Node): void;
	updateHierarchy(): void;
	protected poke(): void;
	updateHierarchyGlobalTransform(): boolean;
	pokeChildren(poked?: boolean): void;
	updateGlobalTransform(poked?: boolean): boolean;
	protected updateTransformData(): void;
	kill(): void;
}
export declare type Rect = {
	x: number;
	y: number;
	width: number;
	height: number;
};
export declare type Point = {
	x: number;
	y: number;
};
export declare class Sprite extends Node {
	protected texture: {
		img?: HTMLImageElement;
		rect?: Rect;
	} | null;
	protected bounds: {
		rect?: Rect;
		boundsUpdated?: boolean;
	} | null;
	protected anchor: Point;
	protected mesh: {
		vertexes?: number[];
		uv?: number[];
		meshUpdated: boolean;
	} | null;
	protected display: {
		visible: boolean;
		alpha: number;
		blend?: string;
	};
	constructor(texture?: HTMLImageElement, frame?: Rect);
	set width(value: number);
	get width(): number;
	set height(value: number);
	get height(): number;
	set visible(value: boolean);
	get visible(): boolean;
	set alpha(value: number);
	get alpha(): number;
	set anchorX(value: number);
	get anchorX(): number;
	set anchorY(value: number);
	get anchorY(): number;
	setAnchor(x?: number, y?: number): void;
	setBlendMode(value: string): void;
	getBlendMode(): string;
	setTexture(img: HTMLImageElement, frame?: Rect): void;
	getTexture(): HTMLImageElement | null;
	setFrame(rect: Rect): void;
	getMesh(): {
		vertexes?: number[];
		uv?: number[];
		meshUpdated: boolean;
	} | null;
	updateMesh(): void;
	updateBounds(): void;
	protected updateTransformData(): void;
	getBounds(): Rect | null;
}
export declare class Renderer {
	static BLEND_MODE: {
		NORMAL: string;
		ADD: string;
		MULTIPLY: string;
	};
	readonly stage: Node;
	sceneWidth: number;
	sceneHeight: number;
	private canvas;
	private readonly vertexData;
	private readonly indexData;
	private vertexOffset;
	private indexOffset;
	private readonly textures;
	private readonly gl;
	private readonly vertexShader;
	private readonly fragmentShader;
	private readonly vs;
	private readonly fs;
	private readonly program;
	private readonly vec2UniformLoc;
	private readonly matABCDCoordLocation;
	private readonly indexBuffer;
	private readonly vertBuffer;
	private currentTexture;
	private currentBlendMode;
	private readonly blendModes;
	constructor(canvas: HTMLCanvasElement);
	resize(width: number, height: number): void;
	createContext(): null | WebGLRenderingContext;
	addTexture(image: HTMLImageElement): void;
	present(): void;
	draw(sprite: Sprite, alpha?: number, blend?: string, poked?: boolean): void;
	drawTriangles(): void;
}
export declare class Timer {
	private requestAnimationFrameId;
	private onEnterFrame;
	private oldTime;
	constructor(cb: (delta: number) => void);
	start(): void;
	stop(): void;
	private onRequestAnimationFrame;
}

export {};
